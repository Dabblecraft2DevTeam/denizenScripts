# This script implements an A* algorithm for finding the shortest path between
# two points (nodes). This will be used for figuring out the shortest railroad connection
# between a player and a fixed starting point in the enhanced farming world.
# Nodes are defined as lists: li@l@x,y,z,world/g_value/f_value
a_star:
    type: procedure
    definitions: start|goal
    speed: 1t
    script:
        - narrate "start <def[start]>"
        - narrate "goal <def[goal]>"
    
        # Nodes that already have been evaluated
        - define closedset <li@>
        #- narrate "closedset <def[closedset]>"
        
        # Nodes waiting to be evaluated.
        - define openset <li@%start%>
        #- narrate "openset <def[openset]>"
        
        # The path to the goal, if it exists.
        - define came_from <li@>
        #- narrate "came_from <def[came_from]>"
        
        # The cost from start along the best known path.
        - define g_start <el@0>
        #- narrate "g_start <def[g_start]>"
        
        # Estimated total cost from start to goal through
        # Heuristic function is the straight Euclidean distance.
        - define f_start <def[g_start].add[<def[start].distance[<def[goal]>]>]>
        #- narrate "f_start <def[f_start]>"
        
        # Continue algorithm as long as there nodes to expand
        # in the open set
        - while <def[openset].is_empty> == false {
            # get node with lowest f value
            - define current <proc[min_f]>
            
            # if the goal was reached, output the path
            # as a list of locations (add failure clause here?)
            - if <def[current]> == <def[goal]> {
                - determine <def[came_from].get_sub_items[1]>
            }
            
            # remove current node from the open set ...
            - define openset <def[openset].exclude[<def[current]>]>
            
            # ... and add it to the closed set
            - define closedset <def[closedset].include[<def[current]>]>
            
            # get valid neighbors of the current node
            - define neighbor_nodes <proc[find_neighbors].context[<def[current].get_sub_items[1]>]>
            
            
            - foreach 
        }


# This helper script finds all valid neighbors of a passed node as
# a list, which will contain a maximum of four nodes (node locations).
# This means that potentially all non-diagonal blocks from y+1 to y-1
# around the origin block can be considered, since rail tracks can
# only be placed on blocks that have a maximum y difference of 1.
find_neighbors:
    type: procedure
    definitions: node
    speed: 1t
    script:
        - narrate "node was <def[node]>"
        
        # center location whose neighbors shall
        # be found by this procedure
        - define loc <def[node].get[1].as_location>
        #- narrate "origin was <def[loc]>"

        # output list of valid neighbors
        - define valid_neighbors <li@>
        
        # Start from top (y+1)
        # Direction: z-1
        - define x <def[loc].x>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z.sub[1]>
        - define world <def[loc].world.name>
        
        - define n1 <l@%x%,%y%,%z%,%world%>
        
        # Direction: z+1
        - define x <def[loc].x>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z.add[1]>
        
        - define n2 <l@%x%,%y%,%z%,%world%>
        
        # Direction: x-1
        - define x <def[loc].x.sub[1]>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z>
        
        - define n3 <l@%x%,%y%,%z%,%world%>
        
        # Direction: x+1
        - define x <def[loc].x.add[1]>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z>
        
        - define n4 <l@%x%,%y%,%z%,%world%>
        
        # Neighboring blocks to be checked
        - define checklist <li@%n1%|%n2%|%n3%|%n4%>
        #- narrate "checklist <def[checklist]>"
        
        - foreach <def[checklist]> {
            - define neighbor <proc[check_rail_placeable].context[<def[value]>]>
            #- narrate "checklist neighbor was <def[neighbor]>" 
       
            # if there was a valid neighbor, add it to the output list
            - if <def[neighbor]> != -1 {
                #- narrate "Adding neighbor <def[neighbor]>"
                - define valid_neighbors <def[valid_neighbors].include[<def[neighbor]>]>
            }
        }
        
        # return list of valid neighbors
        - determine <def[valid_neighbors]>
        
# This helper script checks if a rail can be placed on the passed block or the two
# below it, and returns a valid block location if there was any.
# Careful: The block BELOW the rail has to be compatible, so when the rail is put
# into place, it has to be placed above the location since it is an entity!
#
# Strategy: For each direction, check the blocks
# top-down. Because the maximum y difference is 1,
# the first valid (= rail-compatible, i.e. not water)
# block denies access to the blocks below it, so these
# do not have to be checked unless the blocks above them
# are air.
check_rail_placeable:
    type: procedure
    definitions: loc
    speed: 1t
    script:
        # loop ending condition
        - define status continue
        #- narrate "status was <def[status]>"
        
        # retain origin location by using
        # a new variable
        - define inloc <def[loc]>
        #- narrate "inloc was <def[inloc]>"
        
        # dummy output location for the case
        # that no block matches
        - define outloc -1
        

        # start at top block and go down a maximum
        # of two blocks from the origin loc
        - while <def[status].is[EQUALS].to[continue]> && <def[loc].y.sub[<def[inloc].y>].is[LESS].than[3]> {
            #- narrate "This is iteration %loop_index%"

            # The material of the block the rail should be placed on must
            # be solid (i.e. not water, air...)
            - if <def[inloc].material.is_solid> == true {
            
                # Block is solid, but must not be transparent (chests, glass..)
                - if <def[inloc].material.is_transparent> == false {
                
                    # Block is solid and non-transparent, check if air above
                    - if <def[inloc].above.material> == <m@air> {
                    
                        # Rail is placeable!
                        #- narrate "solid, non-transparent, space above, ACCEPT"
                        - define status abort
                        - define outloc <def[inloc]>
                        
                    # Block is solid and non-transparent,
                    # but there is no free space above
                    } else {
                    
                        # this blocks all potential neighbors below, abort
                        #- narrate "solid, non-transparent, no space above, ABORT"
                        - define status abort
                    }
                
                # Block is solid, but transparent
                } else {
                    
                    # this blocks all potential neighbors below, abort
                    #- narrate "solid, transparent, ABORT"
                    - define status abort
                }
            
            # Block is not solid
            } else {
                
                # if the block is air, the block below might be suitable
                - if <def[inloc].material> == <m@air> {
                
                    # continue with block below
                    #- narrate "non-solid, air, CONTINUE LOWER"
                    - define status continue

                    - define in_x <def[inloc].x>
                    - define in_y <def[inloc].y.sub[1]>
                    - define in_z <def[inloc].z>
                    - define in_world <def[inloc].world.name>

                    - define inloc <l@%in_x%,%in_y%,%in_z%,%in_world%>
                    #- narrate "inloc is now <def[inloc]>"
                
                # else, there's water or lava, which means that the
                # block below is either solid or also water/lava
                } else {
                
                    # hence abort search
                    #- narrate "non-solid, non-air, ABORT"
                    - define status abort
                }
            }
            #- narrate "status was <def[status]> and diff was <def[loc].y.sub[<def[inloc].y>]>"    
        }
        
        # finally return the valid neighbor block or -1, if there was none
        #- narrate "returning..."
        - determine <def[outloc]>
        
# This helper script returns the g value (cost from start) of a node.
g_score:
    type: procedure
    definitions: node
    speed: 1t
    script:
        - define node <def[node].unescaped>
        #- narrate "node was <def[node]>"

        - define g_val <def[node].get_sub_items[2].get[1]>
        #- narrate "g_score was <def[g_val]>"

        - determine <def[g_val]>


# This helper script returns the f value (Estimated total cost until goal) of a node.
f_score:
    type: procedure
    definitions: node
    speed: 1t
    script:
        - define node <def[node].unescaped]>
        #- narrate "node was <def[node]>"

        - define f_val <def[node].get_sub_items[3].get[1]>
        #- narrate "f_score was <def[f_val]>"

        - determine <def[f_val]>

        
# This helper script finds the node with the lowest f value
# in the open set and returns it.
# Usage: <proc[min_f].context[<li@li@loc/g/f|li@loc/g/f.escaped>]>
min_f:
    type: procedure
    definitions: openset
    speed: 1t
    script:
        - define openset <def[openset].unescaped]>
        #- narrate "openset <def[openset]>"

        # set dummy value 
        - define min_f 999999
        
        # iterate through all nodes in the open set
        # and find the one with the lowest f value.
        - foreach <def[openset]> {
            #- narrate "foreach value was <def[value]>"
            - define current_f <proc[f_score].context[<def[value]>]>
            - if  <def[current_f]> < <def[min_f]> {
                - define min_f <def[current_f]>
                - define min_node <def[value]>
            }
        }
        
        - narrate "min_f was <def[min_f]>, min_node was <def[min_node]>"
        - determine <def[min_node]>
