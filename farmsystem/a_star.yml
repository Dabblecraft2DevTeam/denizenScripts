# This script implements an A* algorithm for finding the shortest path between
# two points (nodes). This will be used for figuring out the shortest railroad connection
# between a player and a fixed starting point in the enhanced farming world.
# Nodes are defined as lists: li@l@x,y,z,world/g_value/f_value/came_from_node
a_star:
    type: procedure
    definitions: start|goal
    speed: 1t
    script:
        - narrate "start <def[start]>"
        - narrate "goal <def[goal]>"
    
        # Nodes that already have been evaluated
        - define closedset <li@>
        #- narrate "closedset <def[closedset]>"
        
        # Nodes waiting to be evaluated.
        - define openset <li@%start%>
        #- narrate "openset <def[openset]>"
        
        # The path to the goal, if it exists.
        - define came_from <li@>
        #- narrate "came_from <def[came_from]>"
        
        # The cost from start along the best known path.
        - define g_start <el@0>
        #- narrate "g_start <def[g_start]>"
        
        # Estimated total cost from start to goal through
        # Heuristic function is the straight Euclidean distance.
        - define f_start <def[g_start].add[<def[start].get_sub_items[1].get[1].distance[<def[goal].get_sub_items[1].get[1]>]>]>
        #- narrate "f_start <def[f_start]>"
        
        # Continue algorithm as long as there nodes to expand
        # in the open set
        - while <def[openset].is_empty> == false {
            # get node with lowest f value
            - define current <proc[min_f].context[<def[openset].escaped>]>
            
            # if the goal was reached, output the path
            # as a list of locations (add failure clause here?)
            - if <def[current]> == <def[goal]> {
                - determine <proc[reconstruct_path].context[<def[came_from].escaped>|<def[goal].escaped>]>
            }
            
            # remove current node from the open set ...
            - define openset <def[openset].exclude[<def[current]>]>
            
            # ... and add it to the closed set
            - define closedset <def[closedset].include[<def[current]>]>
            
            # get valid neighbors of the current node
            - define neighbor_nodes <proc[find_neighbors].context[<def[current].escaped>]>
            
            # Step through all neighbor nodes of the current node
            - foreach neighbor_nodes {
                # search neighbors using their location only since g and f values
                # are not yet set; otherwise, they wouldn't be recognized as in the list
                - define neighbor_loc <def[value].get_sub_items[1].get[1]>
                - define neighbor_node <def[closedset].filter[starts_with[li@%neighbor_loc%]]>
                - narrate "neighbor_node was <def[neighbor_node]>"
                
                # then, using the (potentially) found node, try to get
                # its position in the closed set
                - define neighbor_index_closed <def[closedset].find[<def[neighbor_node]>]>
                
                # if the neighbor has been evaluated before
                - if <def[neighbor_index_closed]> == -1 {
                    # do nothing.
                } else {
                    # calculate a preliminary g value for the neighbor node
                    - define distance <def[current].distance[<def[neighbor_node]>]>
                    - define tentative_g_score <proc[g_score].context[<def[current].escaped>].add[<def[distance]>]>
                    
                    # check if neighbor is not in the open set
                    # CHECK IF DOUBLE USE OF NEIGHBOR_NODE IS OK! <-------- TODO
                    - define neighbor_node <def[openset].filter[starts_with[li@%neighbor_loc%]]>
                    - define neighbor_index_open <def[openset].find[<def[neighbor_node]>]>
                    
                    # if neighbor is not in open set or tentative g score is smaller than
                    # the real g score of the neighbor ...
                    - if <def[neighbor_index_open].is[!EQUALS].to[-1]> || <def[tentative_g_score].is[LESS].than[<proc[g_score].context[<def[neighbor_node].escaped>]>]> {
                        
                        # ... update the neighbor node's
                        # g/f-value and came_from node
                        - define new_came_from <def[current].get_sub_items[1].get[1]>
                        - define new_loc <def[neighbor_node].get_sub_items[1].get[1]>
                        - define new_distance <def[neighbor_node].sub_items_get[1].get[1].distance[<def[goal]>.get_sub_items[1].get[1]]>
                        - define new_g_score <def[tentative_g_score]>
                        - define new_f_score <proc[g_score].context[<def[neighbor_node].escaped>].add[<def[new_distance]>]>
                        
                        - define new_neighbor <li@%new_loc%/%new_g_score%/%new_f_score%/%new_came_from%>
                        
                        # replace old node with updated, new node
                        - define neighbor_index <def[neighbor_nodes].find[<def[neighbor_node]>]>
                        - define neighbor_nodes <def[neighbor_nodes].exclude[<def[neighbor_node]>]>
                        - define neighbor_nodes <def[neighbor_nodes].set[<def[new_neighbor]>].at[<def[neighbor_index]>]>
                        
                        # add update neighbor to open set if
                        # it is not yet in there
                        - if <def[neighbor_nodes].find[<def[new_neighbor]>].is[EQUALS].to[-1]> {
                            - define <def[neighbor_nodes].include[<def[new_neighbor]>]>
                        } 
                }
        }
        
        # If we reach the end of the loop without
        # having returned upon encountering the goal node,
        # there was no way from start to goal.
        - determine -1

# This helper script reconstructs the path the algorithm
# has taken, using the "came_from" field in the nodes' definition.
reconstruct_path:
    type: procedure
    definitions: came_from|current
    speed: 1t
    script:
        - define came_from <def[came_from].unescaped>
        - define current <def[current].unescaped>
        
        # path from start to goal
        - define total_path <li@%current%>
        
        # while current node is in the the came_from list
        - while <def[came_from].find[<def[current]>].is[!EQUALS].to[-1]> {
            
            # find previous node by its location saved in the came_from field
            - define current <def[came_from].filter[ends_with[<def[current].get_sub_items[1].get[1]>]]>
            
            # path begins with the last node, so insertions
            # have to be made in reverse order to output the
            # path from start to finish!
            - define total_path <def[total_path].insert[<def[current]>].at[0]>
        }
        
        # return full path
        - determine <def[total_path]>
        
# This helper script finds all valid neighbors of a passed node as
# a list, which will contain a maximum of four nodes.
# This means that potentially all non-diagonal blocks from y+1 to y-1
# around the origin block can be considered, since rail tracks can
# only be placed on blocks that have a maximum y difference of 1.
find_neighbors:
    type: procedure
    definitions: node
    speed: 1t
    script:
        - define node <def[node].unescaped>
        - narrate "node was <def[node]>"
        
        # center location whose neighbors shall
        # be found by this procedure
        - define loc <def[node].get_sub_items[1].get[1].as_location>
        #- narrate "origin was <def[loc]>"

        # output list of valid neighbors
        - define valid_neighbors <li@>
        
        # Start from top (y+1)
        # Direction: z-1
        - define x <def[loc].x>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z.sub[1]>
        - define world <def[loc].world.name>
        
        - define n1 <l@%x%,%y%,%z%,%world%>
        
        # Direction: z+1
        - define x <def[loc].x>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z.add[1]>
        
        - define n2 <l@%x%,%y%,%z%,%world%>
        
        # Direction: x-1
        - define x <def[loc].x.sub[1]>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z>
        
        - define n3 <l@%x%,%y%,%z%,%world%>
        
        # Direction: x+1
        - define x <def[loc].x.add[1]>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z>
        
        - define n4 <l@%x%,%y%,%z%,%world%>
        
        # Neighboring blocks to be checked
        - define checklist <li@%n1%|%n2%|%n3%|%n4%>
        #- narrate "checklist <def[checklist]>"
        
        - foreach <def[checklist]> {
            - define neighbor <proc[check_rail_placeable].context[<def[value]>]>
            #- narrate "checklist neighbor was <def[neighbor]>" 
       
            # if there was a valid neighbor, add it to the output list
            # and calculate its g and f values
            - if <def[neighbor]> != -1 {
                #- narrate "Adding neighbor <def[neighbor]>"
                - define valid_neighbors <def[valid_neighbors].include[<def[neighbor]>]>
            }
        }
        
        # return list of valid neighbors
        - determine <def[valid_neighbors]>
        
# This helper script checks if a rail can be placed on the passed block or the two
# below it, and returns a valid block location if there was any.
# Careful: The block BELOW the rail has to be compatible, so when the rail is put
# into place, it has to be placed above the location since it is an entity!
#
# Strategy: For each direction, check the blocks
# top-down. Because the maximum y difference is 1,
# the first valid (= rail-compatible, i.e. not water)
# block denies access to the blocks below it, so these
# do not have to be checked unless the blocks above them
# are air.
check_rail_placeable:
    type: procedure
    definitions: loc
    speed: 1t
    script:
        # loop ending condition
        - define status continue
        #- narrate "status was <def[status]>"
        
        # retain origin location by using
        # a new variable
        - define inloc <def[loc]>
        #- narrate "inloc was <def[inloc]>"
        
        # dummy output location for the case
        # that no block matches
        - define outloc -1
        

        # start at top block and go down a maximum
        # of two blocks from the origin loc
        - while <def[status].is[EQUALS].to[continue]> && <def[loc].y.sub[<def[inloc].y>].is[LESS].than[3]> {
            #- narrate "This is iteration %loop_index%"

            # The material of the block the rail should be placed on must
            # be solid (i.e. not water, air...)
            - if <def[inloc].material.is_solid> == true {
            
                # Block is solid, but must not be transparent (chests, glass..)
                - if <def[inloc].material.is_transparent> == false {
                
                    # Block is solid and non-transparent, check if air above
                    - if <def[inloc].above.material> == <m@air> {
                    
                        # Rail is placeable!
                        #- narrate "solid, non-transparent, space above, ACCEPT"
                        - define status abort
                        - define outloc <def[inloc]>
                        
                    # Block is solid and non-transparent,
                    # but there is no free space above
                    } else {
                    
                        # this blocks all potential neighbors below, abort
                        #- narrate "solid, non-transparent, no space above, ABORT"
                        - define status abort
                    }
                
                # Block is solid, but transparent
                } else {
                    
                    # this blocks all potential neighbors below, abort
                    #- narrate "solid, transparent, ABORT"
                    - define status abort
                }
            
            # Block is not solid
            } else {
                
                # if the block is air, the block below might be suitable
                - if <def[inloc].material> == <m@air> {
                
                    # continue with block below
                    #- narrate "non-solid, air, CONTINUE LOWER"
                    - define status continue

                    - define in_x <def[inloc].x>
                    - define in_y <def[inloc].y.sub[1]>
                    - define in_z <def[inloc].z>
                    - define in_world <def[inloc].world.name>

                    - define inloc <l@%in_x%,%in_y%,%in_z%,%in_world%>
                    #- narrate "inloc is now <def[inloc]>"
                
                # else, there's water or lava, which means that the
                # block below is either solid or also water/lava
                } else {
                
                    # hence abort search
                    #- narrate "non-solid, non-air, ABORT"
                    - define status abort
                }
            }
            #- narrate "status was <def[status]> and diff was <def[loc].y.sub[<def[inloc].y>]>"    
        }
        
        # finally return the valid neighbor block or -1, if there was none
        #- narrate "returning..."
        - determine <def[outloc]>
        
# This helper script returns the g value (cost from start) of a node.
g_score:
    type: procedure
    definitions: node
    speed: 1t
    script:
        - define node <def[node].unescaped>
        #- narrate "node was <def[node]>"

        - define g_val <def[node].get_sub_items[2].get[1]>
        #- narrate "g_score was <def[g_val]>"

        - determine <def[g_val]>


# This helper script returns the f value (Estimated total cost until goal) of a node.
f_score:
    type: procedure
    definitions: node
    speed: 1t
    script:
        - define node <def[node].unescaped]>
        #- narrate "node was <def[node]>"

        - define f_val <def[node].get_sub_items[3].get[1]>
        #- narrate "f_score was <def[f_val]>"

        - determine <def[f_val]>
        

# This helper script fetches the came_from value from a passed node.
# The came_from value is not an entire node, but instead just the location
# of the node, which can then be looked up.
came_from:
    type: procedure
    definitions: node
    speed: 1t
    script:
        - define node <def[node].unescaped]>
        - define came_from <def[node].get_sub_items[4].get[1]>
        
        - determine <def[came_from]>
        

        
# This helper script finds the node with the lowest f value
# in the open set and returns it.
# Usage: <proc[min_f].context[<li@li@loc/g/f|li@loc/g/f.escaped/came_from>]>
min_f:
    type: procedure
    definitions: openset
    speed: 1t
    script:
        - define openset <def[openset].unescaped]>
        #- narrate "openset <def[openset]>"

        # set dummy value 
        - define min_f 999999
        
        # iterate through all nodes in the open set
        # and find the one with the lowest f value.
        - foreach <def[openset]> {
            #- narrate "foreach value was <def[value]>"
            - define current_f <proc[f_score].context[<def[value]>]>
            - if  <def[current_f]> < <def[min_f]> {
                - define min_f <def[current_f]>
                - define min_node <def[value]>
            }
        }
        
        - narrate "min_f was <def[min_f]>, min_node was <def[min_node]>"
        - determine <def[min_node]>
