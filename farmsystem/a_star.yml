# Will test if there is a railroad path from the player's
# location to a fixed, predefined point.
train:
    type: command
    name: train
    description: "Versucht, einen Zug zur aktuellen Position herbeizurufen."
    usage: /train
    script:
        # hub position
        - define departure_loc <l@1363,68,25,world.block>
        
        # player position without decimals
        - define destination_loc <player.location.below.block>
        
        # invoke A*
        - define path <proc[a_star].context[<li@start/%destination_loc%/0/0/null>|<li@goal/%departure_loc%/0/0/null>]>
        
        # if A* could find a proper path, output it,
        # else, give a error reply.
        - if <def[path]> == -1 {
            - narrate "Es konnte kein gueltiger Pfad gefunden werden!"
        } else {
            #- narrate "Path is <def[path]>"
            - narrate "PFAD GEFUNDEN!"
        }


# This script implements an A* algorithm for finding the shortest path between
# two points (nodes). This will be used for figuring out the shortest railroad connection
# between a player and a fixed starting point in the enhanced farming world.
#
# Nodes are defined as lists: li@node_id/location/g_value/f_value/parent_node_id
#
# The IDs are continuous integers, starting from 0 and going as high as need be. Start and goal
# nodes have string IDs so one doesn't run into issues when dealing with very long
# paths that would exceed a static goal integer id.
# >>>1363,69,25,world
a_star:
    type: procedure
    definitions: start|goal
    speed: 1t
    script:

        #- narrate "start <def[start]>"
        #- narrate "goal <def[goal]>"
    
        # start counting node IDs at 0
        - define node_id_cnt 0
        
        # The path to the goal, if it exists.
        - define came_from <li@>
        
        # The cost from the start along the best known path.
        - define g_score 0
        
        # Estimated total cost from start to goal through
        # Heuristic function is the straight Euclidean distance.
        - define f_score <def[g_score].add[<def[start].get_sub_items[2].get[1].distance[<def[goal].get_sub_items[2].get[1]>]>]>
        - narrate "f_score <def[f_score]>"

        # id/loc/g/f/came_from_id
        # Update g and f scores of the start node.
        - define startloc <def[start].get_sub_items[2].get[1]>
        - define start <li@start/%startloc%/%g_score%/%f_score%/null>
        
        # Nodes waiting to be evaluated. At first, only
        # the "start" node is added.
        - define openset <def[start]>

        # Nodes that already have been evaluated.
        - define closedset <li@>
        
        
        # Continue algorithm as long as there nodes to expand
        # in the open set
        - while <def[openset].is_empty.is[EQUALS].to[false]> {
        
            # get node with lowest f value
            - define current <proc[min_f].context[<def[openset].escaped>]>
            #- narrate "current was <def[current]>"
            
            # remove current node from the open set ...
            #- narrate "openset BEFORE was <def[openset].size>"
            - define openset <def[openset].exclude[<def[current]>]>
            - narrate "closedset size was <def[closedset].size>"
            
            # ... and add it to the closed set
            - define closedset <def[closedset].include[<def[current]>]>
            #- narrate "closedset was <def[closedset]>"
            
            # if the goal was reached, output the path
            # as a list of locations
            - if <def[current].get_sub_items[1].get[1]> == goal {
                # current/goal node was added to closed set, g and f scores
                # don't matter anymore once we're here          
                - determine <proc[reconstruct_path].context[<def[closedset].as_list.escaped>|<def[goal].as_list.escaped>]>
            }
            
            # DEBUG output, show open set as red wool
            - foreach <def[openset]> {
                - showfake <m@red_wool> <def[value].as_list.get_sub_items[2].get[1]> d:<d@30s>
            }

            # DEBUG output, show closed set as blue wool
            - foreach <def[closedset]> {
                - showfake <m@blue_wool> <def[value].as_list.get_sub_items[2].get[1]> d:<d@30s>
            }

            # get valid neighbors of the current node
            - define neighbor_nodes <proc[find_neighbors].context[<def[current].escaped>|<def[g_score]>|<def[node_id_cnt]>|<def[goal].escaped>|<def[closedset].escaped>]>
            #- narrate "NEIS was <def[neighbor_nodes]>"

            # update the id count by adding the number of actually returned neighbors
            # to the initial value
            - define node_id_cnt <def[node_id_cnt].add[<def[neighbor_nodes].size>]>
            
            # Step through all neighbor nodes of the current node
            - foreach <def[neighbor_nodes]> {
            
                #- narrate "value was <def[value]>"

                # search neighbor using their id
                - define neighbor_id <def[value].as_list.get_sub_items[1].get[1]>
                #- narrate "neighbor_id was <def[neighbor_id]>"

                - define neighbor_node <def[closedset].filter[starts_with[<def[neighbor_id]>]]>
                #- narrate "neighbor_node was <def[neighbor_node]>"
                
                # then, using the (potentially) found node, try to get
                # its position in the closed set
                - define neighbor_index_closed <def[closedset].find[<def[neighbor_node]>]>
                
                # if the neighbor has been evaluated before
                - if <def[neighbor_index_closed]> != -1 {
                    # do nothing and continue the loop
                    # with the next neighbor node
                    - foreach next
                }
                
                # calculate a preliminary g value for the neighbor node
                - define distance <def[current].as_list.get_sub_items[2].get[1].distance[<def[value].as_list.get_sub_items[2].get[1]>]>
                - define tentative_g_score <def[current].as_list.get_sub_items[3].get[1].add[<def[distance]>]>
                    
                # check if neighbor is not in the open set
                - define neighbor_node_open <def[openset].filter[starts_with[<def[neighbor_id]>]]>
                - define neighbor_index_open <def[openset].find[<def[neighbor_node_open]>]>
                    
                #- narrate "openset was <def[openset]>"

                # if neighbor is not in open set or tentative g score is smaller than
                # the real g score of the neighbor ...
                - if <def[neighbor_index_open].is[EQUALS].to[-1]> || <def[tentative_g_score].is[LESS].than[<def[value].as_list.get_sub_items[3].get[1]>]> {
                        
                    # ... update the neighbor node's
                    # g/f-value and came_from node
                    - define goal_loc <def[goal].location>
                    
                    - define new_id <def[value].as_list.get_sub_items[1].get[1]>
                    - define new_loc <def[value].as_list.get_sub_items[2].get[1]>
                    - define new_distance <def[new_loc].distance[<def[goal].as_list.get_sub_items[2].get[1]>]>
                    - define new_g_score <def[tentative_g_score]>
                    
                    # old heuristic was the straight line distance
                    #- define new_f_score <def[value].as_list.get_sub_items[3].get[1].add[<def[new_distance]>]>
                    
                    # heuristic is the manhattan distance
                    - define f_x <def[new_loc].x.sub[<def[goal_loc].x>].abs>
                    - define f_y <def[new_loc].y.sub[<def[goal_loc].y>].abs>
                    - define f_z <def[new_loc].z.sub[<def[goal_loc].z>].abs>
                    - define new_f_score <def[f_x].add[<def[f_y].add[<def[y_z]>]>]>
                    
                    - define new_came_from <def[current].get_sub_items[1].get[1]>

                    #- narrate "NEW_DISTANCE is <def[new_distance]>"
                        
                    - define new_neighbor %new_id%/%new_loc%/%new_g_score%/%new_f_score%/%new_came_from%
                    #- narrate "G SECOND <def[new_g_score]>, F SECOND <def[new_f_score]>"

                    # replace old node with updated, new node
                    - define neighbor_index <def[neighbor_nodes].find[<def[value]>]>
                    - define neighbor_nodes <def[neighbor_nodes].exclude[<def[value]>]>
                    - define neighbor_nodes <def[neighbor_nodes].insert[<def[new_neighbor]>].at[<def[neighbor_index]>]>
                        
                    # add updated neighbor to open set if
                    # it is not yet in there
                    - if <def[openset].find[<def[new_neighbor]>]> == -1 {
                        - define openset <def[openset].include[<def[new_neighbor]>]>
                    }
                }
            }
            
            - wait 0.1s
        }
        
        # If we reach the end of the loop without
        # having returned upon encountering the goal node,
        # there was no way from start to goal.
        - determine -1

# This helper script reconstructs the path the algorithm
# has taken, using the "came_from" field in the nodes' definitions.
reconstruct_path:
    type: procedure
    definitions: closedset|current
    speed: 1t
    script:
        - define closedset <def[closedset].unescaped>
        - define current <def[current].unescaped>

        #- narrate "CLOSEDSET was <def[closedset]>, CURRENT was <def[current]>"
        
        # path from start to goal
        - define total_path <li@>
        
        # while current node is in the the closed set ...
        - define parent_id <def[current].as_list.get_sub_items[1].get[1]>
        #- narrate "PARENT_ID was <def[parent_id]>"

        - while <def[closedset].filter[starts_with[<def[parent_id]>]].size.is[MORE].than[0]> {
            
            # ... find previous node by its id saved in the came_from field
            - define current <def[closedset].filter[starts_with[<def[parent_id]>]].get[1]>
            #- narrate "CURRENT was <def[current]>"

            - define parent_id <def[current].as_list.get_sub_items[5].get[1]>

            # path begins with the last node, so insertions
            # have to be made in reverse order to output the
            # path from start to finish!
            - define total_path <def[total_path].insert[<def[current]>].at[0]>
        }
        
        # return full path
        #- narrate "Full path is<&co> <def[total_path]>"
        #- foreach <def[total_path]> {
        #    - narrate "<def[value].as_list.get_sub_items[1].get[1]>"
        #}

        - determine <def[total_path]>
        
# This helper script finds all valid neighbors of a passed node as
# a list, which will contain a maximum of four nodes.
# This means that potentially all non-diagonal blocks from y+1 to y-1
# around the origin block can be considered, since rail tracks can
# only be placed on blocks that have a maximum y difference of 1.
find_neighbors:
    type: procedure
    definitions: node|g_score|id_cnt|goal|closedset
    speed: 1t
    script:
        #- narrate "FIND_NEI <def[node].unescaped> , <def[g_score]> , <def[id_cnt]> , <def[goal].unescaped>"
        - define node <def[node].unescaped>
        - define goal <def[goal].unescaped>
        - define closedset <def[closedset].unescaped>
        
        # center location whose neighbors shall
        # be found by this procedure
        - define loc <def[node].as_list.get_sub_items[2].get[1]>
        #- narrate "origin was <def[loc]>"

        # output list of valid neighbors
        - define valid_neighbors <li@>
        
        # Start from top (y+1)
        # Direction: z-1
        - define x <def[loc].x>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z.sub[1]>
        - define world <def[loc].world.name>
        
        - define n1 <l@%x%,%y%,%z%,%world%>
        
        # Direction: z+1
        - define x <def[loc].x>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z.add[1]>
        
        - define n2 <l@%x%,%y%,%z%,%world%>
        
        # Direction: x-1
        - define x <def[loc].x.sub[1]>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z>
        
        - define n3 <l@%x%,%y%,%z%,%world%>
        
        # Direction: x+1
        - define x <def[loc].x.add[1]>
        - define y <def[loc].y.add[1]>
        - define z <def[loc].z>
        
        - define n4 <l@%x%,%y%,%z%,%world%>
        
        # Neighboring blocks to be checked
        - define checklist <li@%n1%|%n2%|%n3%|%n4%>
        #- narrate "checklist <def[checklist]>"
        
        - foreach <def[checklist]> {
        
            #- narrate "checklist member was <def[value]>"
            - define goal_loc <def[goal].get_sub_items[2].get[1]>
        
            # add information to neighbor node
            - define neighbor_loc <proc[check_rail_placeable].context[<def[value]>]>
            - define neighbor_distance <def[neighbor_loc].distance[<def[node].get_sub_items[2].get[1]>]> 
            - define neighbor_g_score <def[g_score].add[%neighbor_distance%]>

            # old heuristic was the straight line distance
            #- define neighbor_f_score <def[neighbor_loc].distance[<def[goal].get_sub_items[2].get[1]>]>

            # heuristic is the manhattan distance
            - define f_x <def[neighbor_loc].x.sub[<def[goal_loc].x>].abs>
            - define f_y <def[neighbor_loc].y.sub[<def[goal_loc].y>].abs>
            - define f_z <def[neighbor_loc].z.sub[<def[goal_loc].z>].abs>
            - define neighbor_f_score <def[f_x].add[<def[f_y].add[<def[y_z]>]>]>
            
            - define neighbor_parent <def[node].get_sub_items[1].get[1]>

            # if the goal was reached, mark it by using a special ID
            #- narrate "<def[neighbor_loc]> VS <def[goal].as_list.get_sub_items[2].get[1]>"
            - define id_cnt_backup <def[id_cnt]>
            - if <def[neighbor_loc]> == <def[goal].as_list.get_sub_items[2].get[1]> {
                - narrate "FOUND GOAL AS NEIGHBOR"
                - define id_cnt goal
            }

            #- narrate "G_FIRST <def[neighbor_g_score]>, F_FIRST <def[neighbor_f_score]>"
            - define neighbor %id_cnt%/%neighbor_loc%/%neighbor_g_score%/%neighbor_f_score%/%neighbor_parent%
            - define id_cnt <def[id_cnt_backup]>
            - define id_cnt <def[id_cnt].add[1]> 
       
            # if there was a valid neighbor, add it to the output list
            # and calculate its g and f values
            - if <def[neighbor].as_list.get_sub_items[2].get[1]> != -1 {
               
                # don't re-add old nodes that were merely rediscovered
                # with a new ID but same location as a node in the closed set
                - if <def[closedset].as_string.contains[<def[neighbor].as_list.get_sub_items[2].get[1]>]> == false {
                    #- narrate "Adding neighbor <def[neighbor]>"
                    - define valid_neighbors <def[valid_neighbors].include[<def[neighbor]>]>
                }
            }
        }
        
        # return list of valid neighbors
        - determine <def[valid_neighbors]>
        
# This helper script checks if a rail can be placed on the passed block or the two
# below it, and returns a valid block location if there was any.
# Careful: The block BELOW the rail has to be compatible, so when the rail is put
# into place, it has to be placed above the location since it is an entity!
#
# Strategy: For each direction, check the blocks
# top-down. Because the maximum y difference is 1,
# the first valid (= rail-compatible, i.e. not water)
# block denies access to the blocks below it, so these
# do not have to be checked unless the blocks above them
# are air.
check_rail_placeable:
    type: procedure
    definitions: loc
    speed: 1t
    script:
        # loop ending condition
        - define status continue
        #- narrate "status was <def[status]>"
        
        # retain origin location by using
        # a new variable
        - define inloc <def[loc]>
        #- narrate "inloc was <def[inloc]>"
        
        # dummy output location for the case
        # that no block matches
        - define outloc -1
        

        # start at top block and go down a maximum
        # of two blocks from the origin loc
        - while <def[status].is[EQUALS].to[continue]> && <def[loc].y.sub[<def[inloc].y>].is[LESS].than[3]> {
            #- narrate "Inloc y <def[inloc]>"
            #- showfake <m@green_wool> <def[inloc]> d:<d@1s>
            #- wait 0.1s

            # The material of the block the rail should be placed on must
            # be solid (i.e. not water, air...)
            - if <def[inloc].material.is_solid> == true {
            
                # Block is solid, but must not be transparent (chests, glass..)
                - if <def[inloc].material.is_transparent> == false {
                
                    # Block is solid and non-transparent, check if air above
                    - if <def[inloc].above.material> == <m@air> {
                        # Rail is placeable!
                        #- narrate "solid, non-transparent, space above, ACCEPT"
                        - define status abort
                        - define outloc <def[inloc]>
                        
                    # Block is solid and non-transparent,
                    # but there is no free space above
                    } else {
                    
                        # this blocks all potential neighbors below, abort
                        #- narrate "solid, non-transparent, no space above, ABORT"
                        - define status abort
                    }
                
                # Block is solid, but transparent
                } else {
                    
                    # this blocks all potential neighbors below, abort
                    #- narrate "solid, transparent, ABORT"
                    - define status abort
                }
            
            # Block is not solid
            } else {
                
                # if the block is air, the block below might be suitable
                - if <def[inloc].material> == <m@air> {
                
                    # continue with block below
                    #- narrate "non-solid, air, CONTINUE LOWER"
                    - define status continue
                    
                    # location data
                    - define in_x <def[inloc].x>
                    - define in_y <def[inloc].y.sub[1]>
                    - define in_z <def[inloc].z>
                    - define in_world <def[inloc].world.name>

                    - define inloc <l@%in_x%,%in_y%,%in_z%,%in_world%>
                    #- narrate "inloc is now <def[inloc]>"
                
                # else, there's water or lava, which means that the
                # block below is either solid or also water/lava
                } else {
                
                    # hence abort search
                    #- narrate "non-solid, non-air, ABORT"
                    - define status abort
                }
            }
            #- narrate "status was <def[status]> and diff was <def[loc].y.sub[<def[inloc].y>]>"    
        }
        
        # finally return the valid neighbor block or -1, if there was none
        #- narrate "returning..."
        - determine <def[outloc]>
        

        
# This helper script finds the node with the lowest f value
# in the open set and returns it.
min_f:
    type: procedure
    definitions: openset
    speed: 1t
    script:
        - define openset <def[openset].unescaped]>
        #- narrate "openset <def[openset]>"

        # set dummy value 
        - define min_f 999999
        
        # iterate through all nodes in the open set
        # and find the one with the lowest f value.
        - foreach <def[openset]> {
            # - narrate "F_NODE was <def[value]>"
            - define current_f <def[value].as_list.get_sub_items[4].get[1]>
            - if  <def[current_f]> < <def[min_f]> {
                - define min_f <def[current_f]>
                - define min_node <def[value]>
            }
        }
        
        
        #- narrate "node was <def[min_node]>"
        #- define first <def[min_node].as_list.get_sub_items[3].get[1]>
        #- define second <def[min_node].as_list.get_sub_items[4].get[1]>
        #- narrate "H was <def[first].add[<def[second]>]>"

        - determine <def[min_node].as_list>
